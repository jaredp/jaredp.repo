
	open Ast						(* this should probably be specified @ command line *)
	(* Generated by ast-pp *)
	
	(* indentation utilities *)

	type pp_indentation = {
		pp_indentation_curr : string;
		pp_indentation_prev : pp_indentation option
	}
  
	let pp_indentation_level = ref {
		pp_indentation_curr = "\n"; 
		pp_indentation_prev = None
	}
	
	(* balence push_indent with pop_indent *)
	
	let push_indent u = 
		pp_indentation_level := {
			pp_indentation_curr = !pp_indentation_level.pp_indentation_curr  ^ "    ";
			pp_indentation_prev = Some(!pp_indentation_level)
		}
	
	let pop_indent u =
		match !pp_indentation_level.pp_indentation_prev with
			  None -> ()	(* this is actually an error, but we just leave newline *)
			| Some(prev) -> pp_indentation_level := prev
			
	let inner_indent f =
		let str = (push_indent(); f()) in (pop_indent(); str)
	
	(* get the indentation with newline().
	   The default is just a newline, additional pushes are tabs.
	   This way, anytime you want a new line, it will be properly indented *)
	
	let newline u = !pp_indentation_level.pp_indentation_curr
	
	(* builtin functions *)
	
	let enum x = "enum"
	let tuple x = "tuple"
	let string_of_string str = "\"" ^ str ^ "\""
	let string_of_list f l = 
		"["
		^ (inner_indent (fun u -> newline() ^
			String.concat (";"^newline()) (List.map f l)))
		^ newline() ^ "]"

	let string_of_option f = function
		  None -> "None"
		| Some(x) -> f(x)	

    let string_of_ref f r = f (!r)

	let rec  string_of_op obj = (((function OrAsn -> "OrAsn"
| AndAsn -> "AndAsn"
| DivAsn -> "DivAsn"
| MultAsn -> "MultAsn"
| SubAsn -> "SubAsn"
| AddAsn -> "AddAsn"
| Qmark -> "Qmark"
| Or -> "Or"
| And -> "And"
| Geq -> "Geq"
| Greater -> "Greater"
| Leq -> "Leq"
| Less -> "Less"
| Neq -> "Neq"
| Equal -> "Equal"
| Div -> "Div"
| Mult -> "Mult"
| Sub -> "Sub"
| Add -> "Add"
| Assign -> "Assign")) obj)

 and  string_of_t obj = (((function Tuple(x) -> "Tuple(" ^ (string_of_list (string_of_string)) x^")"
| Udt(x) -> "Udt(" ^ string_of_string x^")"
| Void -> "Void"
| Bool -> "Bool"
| String -> "String"
| Float -> "Float"
| Int -> "Int")) obj)

 and  string_of_var_decl obj = (((fun s -> "{" ^
		inner_indent (fun u -> newline() ^ ("vname = " ^ string_of_string s.vname)
 ^ newline() ^ ("vtype = " ^ string_of_t s.vtype)
 ^ newline() ^ ("isTable = " ^ string_of_bool s.isTable)) ^ newline() ^ "}")) obj)

 and  string_of_type_decl obj = (((fun s -> "{" ^
		inner_indent (fun u -> newline() ^ ("tname = " ^ string_of_string s.tname)
 ^ newline() ^ ("members = " ^ (string_of_list (string_of_var_decl)) s.members)) ^ newline() ^ "}")) obj)

 and  string_of_col_access_id obj = (((fun (obj1, obj2) -> "(" ^ ((string_of_option (string_of_string)) obj1) ^ ", " ^ (string_of_string obj2) ^ ")")) obj)

 and  string_of_expr obj = (((function Filter(obj1, obj2) -> "Filter(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_expr obj2) ^ ")"
| Join(obj1, obj2, obj3) -> "Join(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_expr obj2) ^ ", " ^ (string_of_expr obj3) ^ ")"
| Null(obj1, obj2) -> "Null(" ^ (string_of_t obj1) ^ ", " ^ (string_of_bool obj2) ^ ")"
| FPLiteral(x) -> "FPLiteral(" ^ string_of_float x^")"
| BoolLiteral(x) -> "BoolLiteral(" ^ string_of_bool x^")"
| IntLiteral(x) -> "IntLiteral(" ^ string_of_int x^")"
| StringLiteral(x) -> "StringLiteral(" ^ string_of_string x^")"
| Noexpr -> "Noexpr"
| First(x) -> "First(" ^ string_of_expr x^")"
| CastToTable(x) -> "CastToTable(" ^ string_of_expr x^")"
| Cast(obj1, obj2) -> "Cast(" ^ (string_of_t obj1) ^ ", " ^ (string_of_expr obj2) ^ ")"
| Call(obj1, obj2) -> "Call(" ^ (string_of_string obj1) ^ ", " ^ ((string_of_list (string_of_expr)) obj2) ^ ")"
| CurrentVar -> "CurrentVar"
| Attr(obj1, obj2) -> "Attr(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_col_access_id obj2) ^ ")"
| Binop(obj1, obj2, obj3) -> "Binop(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_op obj2) ^ ", " ^ (string_of_expr obj3) ^ ")"
| Id(x) -> "Id(" ^ string_of_string x^")")) obj)

 and  string_of_block_line obj = (((function Vdecl_line(x) -> "Vdecl_line(" ^ string_of_var_decl x^")"
| Statement_line(x) -> "Statement_line(" ^ string_of_stmt x^")")) obj)

 and  string_of_stmt obj = (((function Iter(obj1, obj2, obj3) -> "Iter(" ^ (string_of_string obj1) ^ ", " ^ (string_of_expr obj2) ^ ", " ^ (string_of_stmt obj3) ^ ")"
| DoWhile(obj1, obj2, obj3) -> "DoWhile(" ^ (string_of_stmt obj1) ^ ", " ^ (string_of_expr obj2) ^ ", " ^ (string_of_stmt obj3) ^ ")"
| For(obj1, obj2, obj3, obj4) -> "For(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_expr obj2) ^ ", " ^ (string_of_expr obj3) ^ ", " ^ (string_of_stmt obj4) ^ ")"
| If(obj1, obj2, obj3) -> "If(" ^ (string_of_expr obj1) ^ ", " ^ (string_of_stmt obj2) ^ ", " ^ (string_of_stmt obj3) ^ ")"
| Return(x) -> "Return(" ^ string_of_expr x^")"
| Expr(x) -> "Expr(" ^ string_of_expr x^")"
| Block(x) -> "Block(" ^ (string_of_list (string_of_block_line)) x^")")) obj)

 and  string_of_func_decl obj = (((fun s -> "{" ^
		inner_indent (fun u -> newline() ^ ("ret_table = " ^ string_of_bool s.ret_table)
 ^ newline() ^ ("rettype = " ^ string_of_t s.rettype)
 ^ newline() ^ ("fname = " ^ string_of_string s.fname)
 ^ newline() ^ ("formals = " ^ (string_of_list (string_of_var_decl)) s.formals)
 ^ newline() ^ ("body = " ^ string_of_stmt s.body)) ^ newline() ^ "}")) obj)

 and  string_of_program obj = (((fun s -> "{" ^
		inner_indent (fun u -> newline() ^ ("global_vars = " ^ (string_of_list (string_of_var_decl)) s.global_vars)
 ^ newline() ^ ("functions = " ^ (string_of_list (string_of_func_decl)) s.functions)
 ^ newline() ^ ("types = " ^ (string_of_list (string_of_type_decl)) s.types)
 ^ newline() ^ ("global_code = " ^ (string_of_list (string_of_stmt)) s.global_code)) ^ newline() ^ "}")) obj)

 and  string_of_table_literal obj = (((string_of_list ((string_of_list (string_of_expr))))) obj)

