
	open Namespace						(* this should probably be specified @ command line *)
	(* Generated by ast-pp *)
	
	(* indentation utilities *)

	type pp_indentation = {
		pp_indentation_curr : string;
		pp_indentation_prev : pp_indentation option
	}
  
	let pp_indentation_level = ref {
		pp_indentation_curr = "\n"; 
		pp_indentation_prev = None
	}
	
	(* balence push_indent with pop_indent *)
	
	let push_indent u = 
		pp_indentation_level := {
			pp_indentation_curr = !pp_indentation_level.pp_indentation_curr  ^ "    ";
			pp_indentation_prev = Some(!pp_indentation_level)
		}
	
	let pop_indent u =
		match !pp_indentation_level.pp_indentation_prev with
			  None -> ()	(* this is actually an error, but we just leave newline *)
			| Some(prev) -> pp_indentation_level := prev
			
	let inner_indent f =
		let str = (push_indent(); f()) in (pop_indent(); str)
	
	(* get the indentation with newline().
	   The default is just a newline, additional pushes are tabs.
	   This way, anytime you want a new line, it will be properly indented *)
	
	let newline u = !pp_indentation_level.pp_indentation_curr
	
	(* builtin functions *)
	
	let enum x = "enum"
	let tuple x = "tuple"
	let string_of_string str = "\"" ^ str ^ "\""
	let string_of_list f l = 
		"["
		^ (inner_indent (fun u -> newline() ^
			String.concat (";"^newline()) (List.map f l)))
		^ newline() ^ "]"

	let string_of_option f = function
		  None -> "None"
		| Some(x) -> f(x)	

    let string_of_ref f r = f (!r)

	let rec  string_of_lm_java_name obj = (((fun (obj1, obj2) -> "(" ^ (string_of_string obj1) ^ ", " ^ (string_of_string obj2) ^ ")")) obj)

 and  string_of_lmprimitive obj = (((function Bool -> "Bool"
| String -> "String"
| Float -> "Float"
| Int -> "Int")) obj)

 and  string_of_colname obj = (((fun (obj1, obj2) -> "(" ^ (string_of_string obj1) ^ ", " ^ (string_of_string obj2) ^ ")")) obj)

 and  string_of_lmudt obj = (((fun (obj1, obj2) -> "(" ^ (string_of_lm_java_name obj1) ^ ", " ^ ((string_of_list ((fun (obj1, obj2) -> "(" ^ (string_of_colname obj1) ^ ", " ^ (string_of_lmprimitive obj2) ^ ")"))) obj2) ^ ")")) obj)

 and  string_of_lmtuple obj = (((string_of_list (string_of_lmudt))) obj)

 and  string_of_lmobjecttype obj = (((function TupleUDT(x) -> "TupleUDT(" ^ string_of_lmtuple x^")"
| UDT(x) -> "UDT(" ^ string_of_lmudt x^")")) obj)

 and  string_of_lmtype obj = (((function Void -> "Void"
| Table(x) -> "Table(" ^ string_of_lmobjecttype x^")"
| Singleton(x) -> "Singleton(" ^ string_of_lmobjecttype x^")"
| Primitive(x) -> "Primitive(" ^ string_of_lmprimitive x^")")) obj)

 and  string_of_lmvar obj = (((fun (obj1, obj2) -> "(" ^ (string_of_lm_java_name obj1) ^ ", " ^ (string_of_lmtype obj2) ^ ")")) obj)

 and  string_of_lmfuncsig obj = (((fun (obj1, obj2, obj3) -> "(" ^ (string_of_lm_java_name obj1) ^ ", " ^ (string_of_lmtype obj2) ^ ", " ^ ((string_of_list (string_of_lmtype)) obj3) ^ ")")) obj)

 and  string_of_nsobject obj = (((function NSUDT(x) -> "NSUDT(" ^ string_of_lmudt x^")"
| NSFunc(x) -> "NSFunc(" ^ string_of_lmfuncsig x^")"
| NSVar(x) -> "NSVar(" ^ string_of_lmvar x^")")) obj)

 and  string_of_namespace obj = (((fun s -> "{" ^
		inner_indent (fun u -> newline() ^ ("super_scope = " ^ (string_of_option (string_of_namespace)) s.super_scope)
 ^ newline() ^ ("objects = " ^ (string_of_list ((fun (obj1, obj2) -> "(" ^ (string_of_string obj1) ^ ", " ^ (string_of_nsobject obj2) ^ ")"))) s.objects)
 ^ newline() ^ ("next_id_index = " ^ string_of_int s.next_id_index)
 ^ newline() ^ ("main_class_name = " ^ string_of_string s.main_class_name)
 ^ newline() ^ ("returntype = " ^ (string_of_option (string_of_lmtype)) s.returntype)
 ^ newline() ^ ("default_variable = " ^ (string_of_option ((fun (obj1, obj2) -> "(" ^ (string_of_string obj1) ^ ", " ^ (string_of_lmtype obj2) ^ ")"))) s.default_variable)
 ^ newline() ^ ("captures = " ^ (string_of_ref ((string_of_list (string_of_nsobject)))) s.captures)
 ^ newline() ^ ("isCapturing = " ^ string_of_bool s.isCapturing)) ^ newline() ^ "}")) obj)

